require('dotenv').config();
const fs = require('fs');
const { Client, GatewayIntentBits, Collection, Events, REST, Routes, SlashCommandBuilder } = require('discord.js');
const config = require('./utils/config');

// Create a new client instance
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessageReactions
  ],
});

// Load commands
client.commands = new Collection();
client.slashCommands = new Collection();
const commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));

// Prepare to register slash commands 
const slashCommands = [];

for (const file of commandFiles) {
  const command = require(`./commands/${file}`);
  client.commands.set(command.name, command);
  console.log(`Loaded command: ${command.name}`);
  
  // Create slash command data
  const slashCommand = {
    name: command.name,
    description: command.description || `${command.name} command`,
    options: command.options || [],
    
    // Convert regular command to slash command
    execute: async (interaction, client) => {
      // Get server config
      const serverId = interaction.guild.id;
      const serverConfig = config.getServerConfig(serverId);
      
      try {
        // Check if the command requires admin permissions
        if (command.requiresAdmin) {
          // Check if the user has admin permissions
          if (!interaction.member.permissions.has('Administrator')) {
            return interaction.reply({
              content: '‚ùå You need Administrator permissions to use this command.',
              ephemeral: true
            });
          }
        }
        
        // Defer reply to give us time to process
        await interaction.deferReply();
        
        // Create a mock message object for backward compatibility
        const mockMessage = {
          author: interaction.user,
          member: interaction.member,
          channel: interaction.channel,
          guild: interaction.guild,
          reply: (content) => interaction.followUp(content)
        };
        
        // Extract arguments from options
        const args = [];
        if (interaction.options && interaction.options.data.length > 0) {
          interaction.options.data.forEach(option => {
            args.push(option.value.toString());
          });
        }
        
        // Call the original command with our mock message
        await command.execute(mockMessage, args, client, interaction);
        
      } catch (error) {
        console.error(`Error executing slash command ${command.name}:`, error);
        
        // Reply with error if not already replied
        if (interaction.deferred && !interaction.replied) {
          await interaction.followUp({
            content: 'There was an error executing this command.',
            ephemeral: true
          });
        }
      }
    }
  };
  
  // Add slash command to collection and command list
  client.slashCommands.set(slashCommand.name, slashCommand);
  slashCommands.push({
    name: slashCommand.name,
    description: slashCommand.description,
    options: slashCommand.options
  });
}

// No need to redefine slashCommands or client.slashCommands here, already done above

// Bot ready event
client.once(Events.ClientReady, async () => {
  console.log(`Logged in as ${client.user.tag}!`);
  console.log('Bot is online and ready!');
  
  try {
    // Create REST instance for registering commands
    const rest = new REST({ version: '10' }).setToken(client.token);
    
    // Transform regular commands to slash commands
    console.log('Started refreshing application (/) commands.');
    
    // Register all slash commands
    await rest.put(
      Routes.applicationCommands(client.user.id),
      { body: slashCommands }
    );
    
    console.log('Successfully registered application (/) commands.');
  } catch (error) {
    console.error('Error registering slash commands:', error);
  }
});

// Interaction event handler for slash commands
client.on(Events.InteractionCreate, async interaction => {
  // Check if it's a command
  if (!interaction.isCommand()) return;
  
  const { commandName } = interaction;
  
  console.log(`Slash command received: ${commandName}`);
  
  // Get the slash command
  const command = client.slashCommands.get(commandName);
  
  if (!command) {
    console.log(`Unknown slash command: ${commandName}`);
    return;
  }
  
  try {
    // Execute the slash command
    await command.execute(interaction, client);
  } catch (error) {
    console.error(`Error executing slash command ${commandName}:`, error);
    
    // Reply with error if interaction hasn't been responded to
    if (interaction.replied || interaction.deferred) {
      await interaction.followUp({ 
        content: 'There was an error executing this command.', 
        ephemeral: true 
      });
    } else {
      await interaction.reply({ 
        content: 'There was an error executing this command.', 
        ephemeral: true 
      });
    }
  }
});

// Message event handler (keeping for backward compatibility and image verification)
client.on(Events.MessageCreate, async message => {
  // Ignore messages from bots
  if (message.author.bot) return;

  // Load server configuration
  const serverConfig = config.getServerConfig(message.guild.id);
  const prefix = serverConfig.prefix || '!';

  // Enhanced verification channel logic
  if (serverConfig.verificationChannelId && message.channel.id === serverConfig.verificationChannelId) {
    // Check if the message has an attachment (image)
    if (message.attachments.size > 0) {
      const imageProcessor = require('./utils/imageProcessor');
      const youtubeAPI = require('./utils/youtubeAPI');
      
      try {
        // Get first attachment
        const attachment = message.attachments.first();
        
        // Check if attachment is an image
        if (attachment.contentType && attachment.contentType.startsWith('image/')) {
          // Send status message with nice emoji
          const statusMsg = await message.reply('üîç **Processing your verification image...**\nPlease wait while I check your YouTube subscription.');
          console.log(`Processing verification image from user ${message.author.tag} (${message.author.id})`);
          
          // Process the image
          const imageUrl = attachment.url;
          console.log(`Image URL: ${imageUrl}`);
          
          // Add visual feedback
          await statusMsg.edit('üîç **Processing your verification image...**\n‚è≥ Analyzing screenshot...');
          
          // Process the image to get hash and verify
          const result = await imageProcessor.processImage(imageUrl);
          console.log('Image processing result:', JSON.stringify(result, null, 2));
          
          // Check if this image has been verified before
          if (result.imageHash && serverConfig.verifiedImages && serverConfig.verifiedImages[result.imageHash]) {
            const previousVerification = serverConfig.verifiedImages[result.imageHash];
            const verifiedByUsername = previousVerification.username || 'another user';
            const verifiedAt = new Date(previousVerification.timestamp).toLocaleString();
            
            await statusMsg.edit(`‚ö†Ô∏è **This image has been used before!**\nThis exact image was already verified by **${verifiedByUsername}** on **${verifiedAt}**.\nPlease take a new screenshot of your subscription.`);
            return;
          }
          
          // Update status message
          await statusMsg.edit('üîç **Processing your verification image...**\n‚úÖ Image analyzed\n‚è≥ Verifying subscription...');
          
          // If image processing succeeded and we have a YouTube channel configured
          if (result && result.success === true && serverConfig.youtubeChannelId) {
            console.log(`Verification proceeding with channel ID: ${serverConfig.youtubeChannelId}`);
            
            // Get channel info for better messaging
            let channelInfo = null;
            try {
              channelInfo = await youtubeAPI.getChannelInfo(serverConfig.youtubeChannelId);
              console.log('Channel info for verification:', channelInfo);
              
              // Save channel name for future reference if we got it successfully
              if (channelInfo && channelInfo.title) {
                config.updateServerConfig(message.guild.id, {
                  youtubeChannelName: channelInfo.title
                });
              }
            } catch (error) {
              console.error('Error fetching channel info during verification:', error);
            }
            
            // Verify subscription with YouTube API
            const isSubscribed = await youtubeAPI.verifySubscription(
              result.userId, 
              serverConfig.youtubeChannelId
            );
            
            console.log(`Subscription verification result: ${isSubscribed ? 'Subscribed' : 'Not subscribed'}`);
            
            if (isSubscribed) {
              // Add role to user if role is set
              if (serverConfig.roleId) {
                try {
                  console.log(`Attempting to assign role ID ${serverConfig.roleId} to user ${message.author.id}`);
                  
                  // Final status update before role assignment
                  await statusMsg.edit('üîç **Processing your verification image...**\n‚úÖ Image analyzed\n‚úÖ Subscription verified\n‚è≥ Assigning role...');
                  
                  await message.member.roles.add(serverConfig.roleId);
                  
                  // Success message with channel name (if available)
                  const channelName = channelInfo?.title || serverConfig.youtubeChannelName || 'the YouTube channel';
                  await statusMsg.edit(`‚úÖ **Verification Successful!**\nYou have been verified as a subscriber to **${channelName}**.\nYou have been assigned the **${serverConfig.roleName || 'Subscriber'}** role!`);
                  
                  // Store this verified image hash to prevent reuse
                  if (result.imageHash) {
                    // Create verifiedImages object if it doesn't exist
                    const verifiedImages = serverConfig.verifiedImages || {};
                    
                    // Store verification details
                    verifiedImages[result.imageHash] = {
                      userId: message.author.id,
                      username: message.author.tag,
                      timestamp: new Date().toISOString(),
                      guildId: message.guild.id
                    };
                    
                    // Update server config with new verified image
                    config.updateServerConfig(message.guild.id, {
                      verifiedImages: verifiedImages
                    });
                    
                    console.log(`Saved verified image hash: ${result.imageHash} for user ${message.author.tag}`);
                  }
                  
                  // Send notification if a notification channel is set
                  if (serverConfig.notificationChannelId) {
                    const notificationChannel = message.guild.channels.cache.get(serverConfig.notificationChannelId);
                    if (notificationChannel) {
                      notificationChannel.send(`üéâ **${message.author.tag}** has verified their subscription to **${channelName}**!`);
                    }
                  }
                } catch (error) {
                  console.error('Error assigning role:', error);
                  await statusMsg.edit('‚ö†Ô∏è **Verification Partially Successful**\nYour subscription was verified, but I could not assign the role. Please contact an administrator.');
                }
              } else {
                console.log('No role ID configured for this server');
                await statusMsg.edit('‚úÖ **Verification Successful!**\nHowever, no subscriber role has been set up yet. Please ask an administrator to set up a role using `!setrole`.');
              }
            } else {
              const channelName = channelInfo?.title || serverConfig.youtubeChannelName || 'the YouTube channel';
              await statusMsg.edit(`‚ùå **Verification Failed**\nCould not confirm your subscription to **${channelName}**.\nPlease make sure you are subscribed and try again with a clear screenshot showing your subscription status.`);
            }
          } else {
            console.log('Image processing failed or no YouTube channel configured');
            
            if (!serverConfig.youtubeChannelId) {
              console.log('No YouTube channel ID is set for this server');
              await statusMsg.edit('‚ùå **Verification Failed**\nNo YouTube channel has been set for verification. Please ask an administrator to set up a YouTube channel using `!setyoutubechannel`.');
            } else if (result && !result.success) {
              // Provide specific feedback based on image processing failure
              await statusMsg.edit(`‚ùå **Verification Failed**\nCould not detect subscription indicators in your image.\n\nTips:\n- Make sure your screenshot clearly shows you are subscribed\n- The subscribe button should show "Subscribed"\n- Try a higher quality screenshot`);
            } else {
              await statusMsg.edit('‚ùå **Verification Failed**\nAn unexpected error occurred while processing your verification. Please try again with a clearer screenshot or contact an administrator.');
            }
          }
        } else {
          await message.reply('‚ùå Please upload an **image file** for verification. I need a screenshot showing your YouTube subscription.');
        }
      } catch (error) {
        console.error('Verification error:', error);
        await message.reply('‚ùå An error occurred during verification. Please try again later or contact an administrator.');
      }
    } else if (message.content.startsWith('!')) {
      // If they tried to use a command in verification channel
      await message.reply('‚ùì This channel is for verification only. Please upload a screenshot showing your YouTube subscription to get verified.');
    } else if (!message.attachments.size) {
      // Guide users if they just send a message without an image
      await message.reply('‚ÑπÔ∏è To verify your subscription, please **upload a screenshot** showing that you are subscribed to the YouTube channel. The screenshot should clearly show the "Subscribed" button.');
    }
    
    return; // Exit to prevent command processing in verification channel
  }

  // Command handling
  if (!message.content.startsWith(prefix)) return;

  const args = message.content.slice(prefix.length).trim().split(/ +/);
  const commandName = args.shift().toLowerCase();

  console.log(`Command received: ${commandName}, Arguments: ${args.join(', ')}`);

  if (!client.commands.has(commandName)) {
    console.log(`Unknown command: ${commandName}`);
    return;
  }

  const command = client.commands.get(commandName);
  console.log(`Executing command: ${command.name}`);

  try {
    command.execute(message, args, client);
  } catch (error) {
    console.error(`Error executing command ${commandName}:`, error);
    message.reply('There was an error executing that command.');
  }
});

// Login to Discord
const token = process.env.DISCORD_TOKEN || 'MTM1MTc5NDc0OTk5MjA3NTMwNQ.GskElp.k5uSc-J8z3eBm9JDja4jLBYH4daJuM5cPuJpN8';
client.login(token).catch(error => {
  console.error('Failed to log in:', error);
  process.exit(1);
});

// Error handling for unexpected issues
process.on('unhandledRejection', error => {
  console.error('Unhandled promise rejection:', error);
});

// Enhanced uptime system for 24/7 operation
const uptimeManager = require('./utils/uptimeManager');
const channelWatcher = require('./utils/channelWatcher');

// Set up advanced uptime management
uptimeManager.setupUptimeManager(client);

// Create an enhanced HTTP server for uptime monitoring
const server = uptimeManager.createUptimeServer();

// Start the server on a port that works with UptimeRobot
server.listen(8080, '0.0.0.0', () => {
  console.log('Enhanced uptime monitoring server running on port 8080');
  console.log('Bot is configured for 24/7 operation with automatic reconnection');
});

// Add enhanced heartbeat system to keep the bot alive even when idle
const HEARTBEAT_INTERVAL = 5 * 60 * 1000; // 5 minutes
const UPTIME_ROBOT_PING_INTERVAL = 14 * 60 * 1000; // 14 minutes (keeping under 20 min UptimeRobot limit)

// Setup regular heartbeat
setInterval(() => {
  console.log(`üíì Heartbeat - ${new Date().toISOString()} - Bot is ${client.user ? 'ONLINE' : 'OFFLINE'}`);
  
  // Force garbage collection if available (reduces memory leaks)
  if (global.gc) {
    console.log('Running garbage collection...');
    global.gc();
  }
  
  // Check bot connectivity and force reconnect if needed
  if (!client.user) {
    console.log('Bot appears to be offline, attempting to reconnect...');
    client.login(process.env.DISCORD_TOKEN).catch(error => {
      console.error('Failed to reconnect during heartbeat:', error);
    });
  }
}, HEARTBEAT_INTERVAL);

// Set up self-ping to prevent the bot from sleeping
// This is a backup mechanism in case UptimeRobot fails
setInterval(() => {
  const botUrl = `https://${process.env.REPL_ID}.id.repl.co/uptimerobot`;
  
  // Using built-in https module to avoid axios dependency for this critical function
  const https = require('https');
  try {
    https.get(botUrl, (res) => {
      if (res.statusCode === 200) {
        console.log(`üîÑ Self-ping successful at ${new Date().toISOString()}`);
      } else {
        console.log(`‚ö†Ô∏è Self-ping returned status code: ${res.statusCode}`);
      }
    }).on('error', (e) => {
      console.error('‚ö†Ô∏è Self-ping error:', e.message);
    });
  } catch (error) {
    console.error('Error during self-ping:', error);
  }
}, UPTIME_ROBOT_PING_INTERVAL);

// Start YouTube channel watcher for latest video notifications
client.once('ready', () => {
  // Wait a bit before starting to ensure everything is initialized
  setTimeout(() => {
    channelWatcher.startWatching(client);
    console.log('YouTube channel watcher started - monitoring for new videos');
  }, 10000);
  
  // Also set up a presence with helpful info
  client.user.setPresence({
    activities: [{ 
      name: '!help for commands', 
      type: 3 // WATCHING
    }],
    status: 'online'
  });
});
